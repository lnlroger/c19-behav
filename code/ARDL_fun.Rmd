---
title: "Explore ARDL function"
author: "Lionel Roger"
date: "14/07/2020"
output: html_document
---

```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
library("tidyverse")
library("sjPlot")

source("ARDL_fun.R")

```

## ARDL function

This report is meant to explore the functionality of the ARDL.flex function and provide an overview over its output.

The function is documented in [ARDL_fun.Rd](ARDL_fun.Rd); currently this file needs to be opened in RStudio seperately and then opened using "Preview".

## Data

We will employ data for the maximum period where data is available on Movement (google) and Stringency (Oxford Tracker) at the country level. The function can however be employed for any other set of variables and at any other level of aggregation.

```{r load data, echo = TRUE}
# Prepare dataset (take differences, drop unnecessary variables and missing observations)
df.now <- read_rds("../df_covid_long.rds") %>%
  filter(sub_region_1 == "") %>%
  group_by(Country) %>%
  mutate(diff.Movement = c(NA, diff(Movement)),
         diff.StringencyIndex = c(NA, diff(StringencyIndex))) %>%
  dplyr::select(Country, Date, diff.Movement, diff.StringencyIndex, Movement, StringencyIndex) %>%
  drop_na()


```

Note: We take first differences of the series, which is because they are very obviously non-stationary; this will typically have to be done prior to using the data.

```{r plot1, echo=FALSE}

df.plot <- df.now %>%
  pivot_longer(cols = c(Movement,StringencyIndex,diff.Movement,diff.StringencyIndex), 
               names_to = "series") %>%
  filter(Country %in% unique(df.now$Country)[seq(1,100,5)])

ggplot(df.plot[which(df.plot$series %in% c("StringencyIndex","diff.StringencyIndex")),], aes(Date,value,colour = series)) +
  geom_line() +
  facet_wrap(~ Country) +
  theme_minimal()

ggplot(df.plot[which(df.plot$series %in% c("Movement","diff.Movement")),], aes(Date,value,colour = series)) +
  geom_line() +
  facet_wrap(~ Country) +
  theme_minimal()


```


On top of non-stationarity, which is fixed by differencing (see above), there seems to be a strong seasonal character in the Movement series: perhaps movement reductions relative to pre-pandemic times are stronger on weekends, when mostly non-essential activities take place; or on weekdays, when mostly banned activities take place?
To remove this seasonality, ARDL.flex has a functionality that removes the seasonal character from the series by regressing seasonal dummies onto it, and replacing the series with the residuals; see Lovell (1963). Below, I just run that same function that ARDL.flex recurs to (I seperated it out) and plot it to see what it effectively does.


```{r plot.season, echo=FALSE}

df.now$weekdays <- weekdays(df.now$Date)
df.now$diff.Movement.cleaned <- remove.seasonality(data = df.now,
                                                   var.to.clean = "diff.Movement",
                                                   seasonal.var = "weekdays")

df.plot <- df.now %>%
  pivot_longer(cols = c(diff.Movement,diff.Movement.cleaned), 
               names_to = "series") %>%
  filter(Country %in% c(unique(df.now$Country)[seq(1,100,25)], "Jordan"))

ggplot(df.plot[which(df.plot$series %in% c("diff.Movement.cleaned","diff.Movement")),], aes(Date,value,colour = series)) +
  geom_line() +
  facet_grid(rows = series ~ Country) +
  theme_minimal()

```

Not revolutionary, maybe the cyclical element isn't as strong as initially thought, or a different method for removing it would be more appropriate. 
Also, what's up with Jordan? I included it deliberately for I noticed its weirdness.

Looking at the output of the lm() estimations associated with the de-seasoning, some weekdays tend to be significant however; which ones does depend on the country, I haven't really looked into it yet.

## Use and output

Let's run the function; I will set it to perform our standard application, regressing Stringency on Movement; I will let it choose from any lag length up to 12, which obviously takes a little bit of time to run.

Note that the parameters below are explicitely written out for the sake of exposition, but they 'happen' to correspond to the defaults - meaning that ARDL.flex() without further arguments would do in this narrow context.

```{r ardl.flex, echo = TRUE, results="hide", warning=FALSE, message=FALSE}

# output.ardl <- ARDL.flex(data.input = df.now,
#                        depvar = "diff.Movement",
#                        indepvar = "diff.StringencyIndex",
#                        max.p = 12, max.q = 12,
#                        write.output = TRUE,
#                        by.var = "Country",
#                        vars.to.deseason = "diff.Movement",
#                        seasonality = "weekday",
#                        t.min = 30)
# 
load("ARDL-output.RData")


```


The output is a list with 5 elements, the central one being 'summary' - a table with one entry per country, describing the preferred model for that country and key results (currently the long-run coefficient).

```{r summary1, echo=TRUE}

head(output.ardl$summary)


```


Additionally, there are elements containing key parameters for all models considered stored in the form of matrices; these currently include the BG test for autocorrelation and the BIC (both used to select the model) as well as the long-run coefficient resulting from each of the models (as a quick check for parameter stability). For example:

```{r lrmatrix, echo=TRUE}
output.ardl$longrun$Zimbabwe

```

This lends itself to a surface plot or heatmap representation such as this (deliberately simplistic):

```{r heatmap}
heatmap(output.ardl$longrun$Zimbabwe, Rowv = NA,Colv = NA)
```



Lastly, all 'winning' models are saved in their entirety as ardlDlm objects, and can be called and treated in the same fashion as any lm object:

```{r model, echo=TRUE}

summary(output.ardl$model$Zimbabwe)

```


## Results

First, note that the criteria like fairly 'rich' models (including many lags):

```{r lang length, echo=FALSE}

output.ardl$summary %>%
  summarise(average.p = mean(p.best),
            average.q = mean(q.best))

```

Funny that these are so similar, I wonder if there's a reason for that.

Now let's look at the parameter of interest, the long run coefficient:

```{r lrcoeff, echo=FALSE, fig.height=16, fig.width=8}
df.plot<- output.ardl$summary %>%
  mutate(ObsUnit = forcats::fct_reorder(ObsUnit,-LongRunCoefficient))

ggplot(df.plot,
       aes(x = LongRunCoefficient, y = ObsUnit)) + 
  geom_point(colour = "blue") +
  geom_vline(xintercept = 0, colour = "red") +
  theme_bw() 

```


I consider it good news that only 3 countries exhibit a (mildly) positive coefficient, unlike in previous and more preliminary estimates.

## Correlates of LR coefficients

Let's turn to potential correlates of those long-run coefficients.

```{r correlates prep, echo=FALSE, warning=FALSE,message=FALSE}
setwd("..")
source("ImportLong.r")

df2<-df%>%
  filter(!is.na(StringencyIndex),!is.na(Movement))
  
  

library("plyr")
#Break up w1 by country, then fit specified model to each piec and return a list
models<-dlply(df2,'Country',function(df)
  lm(Movement~StringencyIndex,data=df))

#apply coef to each model and return a data frame
q<-ldply(models,coef)
names(q)<-c("Country","Intercept","Compliance")


#breaks<-df%>%
 # filter(Popular==1)%>%
  #dplyr::select(Country)

df_avg<-df%>%
 filter(!is.na(Movement),!is.na(StringencyIndex))%>%
  group_by(Country)%>%
  summarise_at(vars(-c(total_deaths,total_cases)),mean,na.rn=TRUE)%>%
  ungroup()

df_other<-df%>%
   filter(!is.na(Movement),!is.na(StringencyIndex))%>%
  group_by(Country)%>%
  dplyr::summarise(total_deaths=last(total_deaths),total_cases=last(total_cases),LogDeath=(log(last(total_deaths)+1)),LogCases=log(last(total_cases)+1),MaxSI=max(StringencyIndex,na.rm=TRUE))%>%
  ungroup()

df_short<-merge(df_avg,df_other,by="Country",all=T)  
df_short<-merge(df_short,q,by="Country",all=T) 
df_short<-merge(df_short,output.ardl$summary[,c("ObsUnit","LongRunCoefficient")],by.x="Country",
                by.y = "ObsUnit",all=T)

vars_basic<-c("log_GDP_pc","Unemployment","Pop_Density_sq_mi","Age_65up","Death_disease")
vars_basic_GDP<-c("Unemployment","Pop_Density_sq_mi","Age_65up","Death_disease")
vars_briq<-c("risktaking","patience","negrecip","trust","posrecip","altruism")
vars_hof<-c("COL","PDI","MAS","UAI")
```




```{r regressions, echo=FALSE}

basic<-formula(paste("LongRunCoefficient ~", paste(vars_basic, sep = "", collapse = "+")))
basic_mob<-lm(data=df_short,basic)

briq<-formula(paste("LongRunCoefficient ~", paste(c(vars_basic,vars_briq,"ROL"), sep = "", collapse = "+")))
briq_mob<-lm(data=df_short,briq)

hof<-formula(paste("LongRunCoefficient ~", paste(c(vars_basic,vars_briq,"ROL",vars_hof), sep = "", collapse = "+")))
hof_mob<-lm(data=df_short,hof)

tab_model(basic_mob,briq_mob,hof_mob)

```

Somewhat different to earlier estimates; not sure how intuitive, needs closer consideration.

A different angle:


```{r boxplot, echo=FALSE, message=FALSE, warning=FALSE}

library("mosaic")

df.plot <- df_short %>%
  mutate(Regime = derivedFactor(
    "Autocracy" = polity2 <= -6,
    "Anocracy" = (polity2 > -6 & polity2 < 6),
    "Democracy" = polity2 >= 6)
    )

ggplot(df.plot, aes(y=LongRunCoefficient,colour = Regime)) +
  geom_boxplot() +
  theme_bw() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

```

Immediate observation is that there is a huge diversity among democracies; maybe this can be fine tuned by removing outliers or so.


```{r boxplot2, echo=FALSE}

library(countrycode)

df.plot$Continent <- countrycode(df.plot$Country,origin = "country.name", destination = "continent")

ggplot(df.plot, aes(y=LongRunCoefficient,colour = Continent)) +
  geom_boxplot() +
  theme_bw() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

```

Perhaps this plots would be informative anyway, also for other metrics (such as average movement, for instance).
